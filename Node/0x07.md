### [Getting Single Page Application Security Right by Philippe De Ryck](https://www.youtube.com/watch?v=UFPGOvDrTOk&t=2462s)

 - OS on home devices should verify the certification so that attacke won't be able to do MITM, as in the case of samsung smart refrigirator.
 - [Book] primer on client-side web security 
 - If you make changes in the single page application (SPA) the changes are immediately saved on the browser and send to the server later in the background. Ex, FB like button.
	 - Its great in performance and UI wise.
	 - Server response is just OK instead of sending back the data as seen in Traditional website. 
 - Firefox OS is essentially an operatinf system which runs in the browser, kinda SPA.
	 - Microkernel
	 - Governed by Web Security Policies.
 - Session Management
	 - HTTP is a stateless protocol
		 - Multiple request from the same client are not related to each other.
		 - The server has no way to store temporary state.
	 - Cookies make HTTP Stateful
		 - Client send the request to server
		 - Server send the page 
		 - client login to the page
		 - server authenticates, if true set the session ID saves the authentication state in session object and send set cookie in the respose with session id as value. It also sends some othr values like Expire, HTTPOnly , Secure, Domain.
		 - Next request , the browser will send the cookie automatically
		 - Server looks up the cookie
		 - Instead of setting the session id as incremental no. or general names server should use longer random values which is not guessable.
		 - But cookie doesn't work well with REST apis.
			 - That's why we store the state on the client side instead on server.
	 - Client Side Sessions
		 - Actually holds the data instead of an identifier.
		 - Server Side sessions depend on sessionid unguessability
		 - Client Side sessions depends on session data integrity.
			 - In Node Express if server set a cookie it will set it in pair -
				 - One Session Data - session:data
				 - One Signature - sesssion.sig:r3r3rj3irh3rn4r
			 
 - **Cross Side Request Forgery**
	 - It doesn't mate whether the cookie is client-side or serverside, if protection is not implemented it can cause CSRF attack.
	 - Malicious sites triggered unintended requests from user's browser.
		 - One protection is to set HTML token send as a hidden parameter.
		 - It requires server to hold state.
	 - Origin Header check
		 - Sent by browser for POST,PUT,DELETE Requests basically the state changing requests.
	 - Transparent cookies. (Helpful incase of stateless API's)
		 - Server set the cookie with the CSRF Token
		 - On client, the page set the csrf cookie as a header and sent to the server.
		 - Attacker can not set the cookie for the domain, as it is protected by same origin policy
		 - On AngularJS it is default way to protect from CSRF attacks.
	 - Token Based Stateful solution completely eliminates CSRF attacks.
		 - JWT
 - **JSON WEB TOKEN (JWT)**
	 - It's like a blob of data
	 - Contains three sections of Base64 encoded data seperated by dot.
		 - Header
			 - Type of Signature : HS265
			 - Type of token : JWT
		 - Payload
		 - Signature
			 - Header + Payload
	 - JWT doesn't provide any confidentiality by default, don't store sensitive data
	 - AngularJS stores these kind of data in Local Storage
		 - *Vulneabilities*
			 - It supports `none` alogorithm which doesn't do any signing	
			 - Confusion between HMAC and public key crypto
				 - Using public information to sign tokens.
 

 - **Cross Site Scripting**
	 - How impactful XSS can be - Apache bug tracker pawned
	 - XSS leads to the attacker controller code in  context of vulnerable application in the victim browser.
	 - Protection
		 - Use context sensitive encoding
			 - HTML Body
			 - HTML Attributes
			 - Stylesheet 
			 - Script
			 - URL
 -  **CSP**
	 - CSP reduces the harm of content injection
		 - By telling the client from where the resource should be loaded from
		 - by disabling dangerous features .
	 - CSP is  intendedas second line of defence.
	 - A policy consist of set of directives.
	 - CSP was a research paper from mozilla team
	 - It prevents the use of eval()
	 - Deprecates X-FRAME-OPTIONS header
	 - `unsafe-inline` is not recommended.
	 - `unsafe-eval` is required by some frameworks, AngJS
	 - Ember enables CSP by default

 - **CORS**
	 - Server Side Proxy
		 - Proxy basically collects the response from the server and forward it to client, so that it looks like the response is comming from the same domian.
	 - JSONP
		 - IMG and SCRIPTS are outside of SOP restriction.
	 - CORS allows the server to tell the server that the specific origin is allowed to to access the resource.
	 - CORS is relaxation of SOP , but controlled by server.
	 -  The browser restrics the browser to check on XHR calls
	 - If allowed access to response is granted otherwise denied.
		 - XHR sends the request with origin header, if in response Access-control-origin-header contains the header as whitelisted the browser allows to read the response.
	 - Handling Credentials.
		 - Requests can be anonymous or authenticated.
			 - by default credentials(cookies) are not sent.
			 - can be enabled by setting the `withCredentials` flag
	 - When credentials are use , server must acknowledge this
		 - by sending Access-Control-Allow-Credentials
			 - Only appiles to cookies.
			 - xhr.withCredentials required to set otherwise it won't send cookies.
	 - Denying access to response protects sensitive data.
		 - Prevents the attacker from reading the user's data
	 - Non-simple requests-
		 - Unlike Post, request like DELETE 
			 - CORS address this problem with preflight requests.
			 - preflight requests asks for persmission
	 - FLOW of preflight requests-
		 - Requests
			 - OPTIONS
			 - ORIGIN
			 - ACCESS-CONTROL-ALLOW-HEADERS
		 - RESPO
			 - ACCESS-CONTROL-ALLOW-METHODS: GET,DELETE,PUT
			 - ACCESS-CONTROL-ALLOW-ORIGIN : *
		 - Actual Request
			 - Delete
		 - Response
			 - Deleted
		 - For efficiency it is cached by browser.
		 - In case of JWT preflight is mandatory
	 - Images in contrary to canvs has different properties.
		 - Img tag allows us to fetch images and display it on page with width & height defined.
		 - Canvas tag allow us to access each pixel and we can manupulate it also.
	
		
	
